% \iffalse meta-comment
%
% Copyright (C) 2008-2009 by Elie Roux and Yannis Haralambous
% <elie.roux@telecom-bretagne.eu>.
%
% This work is under the CC0 license.
%
% This Current Maintainer of this work is Elie Roux.
%
% This work consists of the main source file luaminimalotf.dtx
% and the derived files
%    luaminimalotf.sty, luaminimalotf.lua, luaminimalotf.drv and luaminimalotf.pdf.
%
%
% Unpacking:
%    tex luaminimalotf.dtx
% 
% Documentation:
%    pdflatex luaminimalotf.drv
%
%    The class ltxdoc loads the configuration file ltxdoc.cfg
%    if available. Here you can specify further options, e.g.
%    use A4 as paper format:
%       \PassOptionsToClass{a4paper}{article}
%
%
%<*ignore>
\begingroup
  \def\x{LaTeX2e}%
\expandafter\endgroup
\ifcase 0\ifx\install y1\fi\expandafter
         \ifx\csname processbatchFile\endcsname\relax\else1\fi
         \ifx\fmtname\x\else 1\fi\relax
\else\csname fi\endcsname
%</ignore>
%<*install>
\input docstrip.tex
\Msg{************************************************************************}
\Msg{* Installation}
\Msg{* Package: luaminimalotf 2009/03/09 v0.1 LuaTeX minimal otf support.}
\Msg{************************************************************************}

\keepsilent
\askforoverwritefalse

\let\MetaPrefix\relax

\preamble
This is a generated file.

Copyright (C) 2007-2009 by Yannis Haralambous
<elie.roux@telecom-bretagne.eu>.

This work is under the CC0 license.

This Current Maintainer of this work is Elie Roux.

This work consists of the main source file luaminimalotf.dtx
and the derived files
   luaminimalotf.sty, luaminimalotf.lua, luaminimalotf.drv and luaminimalotf.pdf.

\endpreamble

\let\MetaPrefix\DoubleperCent

\generate{%
  \file{luaminimalotf.drv}{\from{luaminimalotf.dtx}{driver}}%
  \usedir{tex/luatex/mplib}%
  \file{luaminimalotf.sty}{\from{luaminimalotf.dtx}{package}}%
}

% The following hacks are to generate a lua file with lua comments starting by -- instead of %%

\def\MetaPrefix{-- }

\def\luapostamble{%
  \MetaPrefix^^J%
  \MetaPrefix\space End of File `\outFileName'.%
}

\def\currentpostamble{\luapostamble}%

\generate{%
  \usedir{tex/luatex/mplib}%
  \file{luaminimalotf.lua}{\from{luaminimalotf.dtx}{lua}}%
}

\obeyspaces
\Msg{************************************************************************}
\Msg{*}
\Msg{* To finish the installation you have to move the following}
\Msg{* files into a directory searched by TeX:}
\Msg{*}
\Msg{*     luaminimalotf.sty luaminimalotf.lua}
\Msg{*}
\Msg{* Happy TeXing!}
\Msg{*}
\Msg{************************************************************************}

\endbatchfile
%</install>
%<*ignore>
\fi
%</ignore>
%<*driver>
\NeedsTeXFormat{LaTeX2e}
\ProvidesFile{luaminimalotf.drv}%
  [2009/03/08 v1.01 mplib package for LuaTeX.]%
\documentclass{ltxdoc}
\begin{document}
  \DocInput{luaminimalotf.dtx}%
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \GetFileInfo{luaminimalotf.drv}
%
% \title{The \textsf{luaminimalotf} package}
% \date{2009/03/09 v0.1}
% \author{Yannis Haralambous, Arthur Reutenauer and Elie Roux \\ \texttt{elie.roux@telecom-bretagne.eu}}
%
% \maketitle
%
% \begin{abstract}
% Package to provide minimal otf font support for Lua\TeX .
% \end{abstract}
%
% \section{Documentation}
%
% This packages aims at providing a minimal support for otf fonts in Lua\TeX . Lua\TeX\ is built with the lua \texttt{fontforge} library, that can virtually open any kind of font, including otf. This package allows Lua\TeX\ to read otf fonts with this library.
%
% A complete support for otf fonts is something too big to be done before \TeX Live 2009 gets released, this package must be seen as a transition before a true otf support. It has extremely strong limitations: the main being it doesn't understand any otf feature, ligatures for example. Because of this, it will be useful to test some fonts or to use fonts for initials, but in no way it can be relied on as a true otf package.
%
% The only think this package does is making the \texttt{\string\font} primitive accept fonts with \texttt{.otf} extention.
%
% Another limitation is that this package (and potentially any otf support) works only in PDF mode.
%
% The package registers a function the \texttt{define\_font} callback. Currently this callback allows only one function registered in it, so you won't be able to use this package with another one registering a function in this callback.
%
% \section{Files}
%
% This package contains three files:
% \begin{itemize}
% \item \texttt{luaminimalotf.lua} containing the lua code
% \item \texttt{luaminimalotf.sty}, a wrapper for the lua code, working for both Plain and \LaTeX
% \end{itemize}
%
% \iffalse
%<*lua>
% \fi
%
% \subsection{\texttt{luaminimalotf.lua}}
%
% First the \texttt{luaminimalotf} module is registered as a Lua\TeX\ module, with some informations.
%
%    \begin{macrocode}

luaminimalotf = { }

luaminimalotf.module = {
    name          = "luaminimalotf",
    version       =  0.1,
    date          = "2009/03/09",
    description   = "LuaTeX minimal otf support.",
    author        = "Yannis Haralambous & Arthur Reutenauer",
    copyright     = "Yannis Haralambous",
    license       = "CC0",
}

luatextra.provides_module(luaminimalotf.module)

%    \end{macrocode}
%
% The main code. This function will be registered in the \texttt{define\_font} callback.
%
%    \begin{macrocode}

function parse_cidmap(cidmap, cidpath)
  local decdigit = lpeg.R"09"
  local hexdigit = decdigit + lpeg.R"af" + lpeg.R"AF"
  local alpha = lpeg.R"az" + lpeg.R"AZ"
  local alnum = alpha + decdigit
  local dot = lpeg.P"."

  local cidrange = lpeg.C(decdigit^1) * (lpeg.P".." * lpeg.C(decdigit^1))^-1
  cidrange = lpeg.Ct(cidrange)
  local usv = lpeg.Cc"usv" * lpeg.C(hexdigit^1)
  usv = lpeg.Ct(usv)
  local glyphname = lpeg.Cc"name" * lpeg.P"/"
    * lpeg.C((alpha + dot) * (alnum + dot)^1)
  glyphname = lpeg.Ct(glyphname)
  local space = lpeg.P" " + lpeg.P"\t"

  local cidpatt = cidrange * space^1 * (usv + glyphname)
  local first_line = true
  local cidcount

  for cidline in io.lines(cidpath) do
    if first_line then
      cidcount = cidline:gmatch("[0-9]+")()
      first_line = false
    else
      cids, codes = lpeg.match(cidpatt, cidline)
      cid = tonumber(cids[1], 10)
      if codes[1] == "usv" then -- else code[1] == "name"; do nothing
        code = tonumber(codes[2], 16)
        last_cid = tonumber(cids[2], 10)
        if not last_cid then
          cidmap[cid] = code
        else
          for n = cid, last_cid do
            i = n - cid
            cidmap[cid + i] = code + i
          end
        end
      end
    end
  end
end

function find_cidmap(registry, ordering, supplement)
  local cidmap = { }

  registry = registry:lower()
  ordering = ordering:lower()
  local cidfile = string.format("%s-%s-%d", registry, ordering, supplement)
  kpse.set_program_name("luatex")
  local cidpath = kpse.find_file(string.format("%s.cidmap", cidfile))
  if not cidpath
  then cidpath = string.format("cidmap/%s.cidmap", cidfile)
  end
  parse_cidmap(cidmap, cidpath)
  --[===[
  for k, v in pairs(cidmap) do
    out:write(string.format("%d\t%04x", k, v))
    out:write("\n")
  end
  --]===]
  return cidmap
end


function luaminimalotf.open_font (name, size)
  local tfont, ofont = { }
  local fonttype
  local filename = kpse.find_file(name,"opentype fonts")
  if filename
  then fonttype = 'opentype'
  else filename = kpse.find_file(name, "truetype fonts")
  end
  if filename and not fonttype then fonttype = 'truetype' end
  if fonttype then
    if size < 0 then size = -655.36 * size end

    local ffont = fontforge.open(filename)
    ofont = fontforge.to_table(ffont)
    fontforge.close(ffont)
    if ofont then
      tfont.name = ofont.fontname
      tfont.fullname = ofont.names[1].names.fullname
      tfont.parameters = { }
      tfont.designsize = size
      tfont.size = size
      direction = 0
      tfont.parameters.slant = 0
      tfont.parameters.space = size * 0.25
      tfont.parameters.space_stretch = 0.3 * size
      tfont.parameters.space_shrink = 0.1 * size
      tfont.parameters.x_height = 0.4 * size
      tfont.parameters.quad = 1.0 * size
      tfont.parameters.extra_space = 0
      tfont.characters = { }
      local mag = size / ofont.units_per_em

      local cidmap
      local ci = ofont.cidinfo
      if ci then
        local reg, ord, supp = ci.registry, ci.ordering, ci.supplement
        if reg and ord and supp then
          if cidinfo ~= "Identity"
	  then cidmap = find_cidmap(reg, ord, supp)
          end
        end
      end

      tfont.map = ofont.map

      local names_of_char = { }
      if ofont.map then
        if ofont.map.map then
          for char, glyph in pairs(ofont.map.map)
          do
            names_of_char[ofont.glyphs[glyph].name]
              = ofont.map.backmap[glyph]
          end
  
          names_of_glyph = { }
          for char, glyph in pairs(ofont.map.map)
          do
            names_of_glyph[ofont.glyphs[glyph].name]
              = glyph
          end
        end

        tfont.map.names_of_char = names_of_char
      end

      local function tex_char_table(glyph_table, char, glyph)
        local w = glyph_table.width
        if not w then w = 0 end
        w = w * mag
        local char_table = {
          index = glyph,
          width = w,
          name = glyph_table.name,
          lookups = glyph_table.lookups
        }

        if glyph_table.boundingbox then
          if glyph_table.boundingbox[4]
          then char_table.height = glyph_table.boundingbox[4] * mag
          end

          if glyph_table.boundingbox[2]
          then char_table.depth = -glyph_table.boundingbox[2] * mag end
        end

        if glyph_table.kerns then
        local kerns = { }
        for _, kern in pairs(glyph_table.kerns)
        -- Dangerous!
        do kerns[names_of_char[kern.char]] = kern.off * mag
        end
        char_table.kerns = kerns
        end

        return char_table
      end

      -- construct tfont.characters
      if ofont.subfonts then
        if cidmap then
          for _, sf in ipairs(ofont.subfonts) do -- ipairs, really?
            for glyph, glyph_table in pairs(sf.glyphs) do
              if glyph_table.width then -- subfonts contain a lot of crap!
                local char = cidmap[glyph]
                if char then -- glyph can be 0?
                  local char_table =
                    tex_char_table(glyph_table, char, glyph)
                  if char_table then tfont.characters[char] = char_table end
                end
              end
            end
          end
        end
      else
        for char, glyph in pairs(ofont.map.map) do
          glyph_table = ofont.glyphs[glyph]
          local char_table = tex_char_table(glyph_table, char, glyph)
          if char_table then tfont.characters[char] = char_table end
        end
      end

      tfont.filename = filename
      tfont.type = 'real'
      tfont.format = fonttype
      tfont.embedding = "subset"
      -- Really?
      tfont.cidinfo = {
        registry = "Adobe",
        ordering = "Identity",
        supplement = 0,
        version = 1
      }
    end
  else
    tfont = font.read_tfm(name, size)
  end
  return tfont
end

function luaminimalotf.add_callback()
    callback.add('define_font', luaminimalotf.open_font, 'luaminimalotf.open_font')
end

%    \end{macrocode}
%
% \iffalse
%</lua>
% \fi
%
% \subsection{\texttt{luaminimalotf.sty}}
%
% \iffalse
%<*package>
% \fi
%
% The file just checks the pdf mode, registers the package and calls the lua code.
%
%    \begin{macrocode}

\expandafter\ifx\csname ProvidesPackage\endcsname\relax
\expandafter\ifx\csname luaUseModule\endcsname\relax
\input luatextra.sty
\fi
\else
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{luaminimalotf}%
  [2009/03/09 v0.1 LuaTeX minimal otf support]
\@ifpackageloaded{luatextra}{}{\RequirePackage{luatextra}}
\fi

\luaUseModule{luaminimalotf}

\ifnum\pdfoutput<1
  \expandafter\ifx\csname PackageWarning\endcsname\relax
    \write16{}
    \write16{Warning: luaminimalotf only works in PDF mode, otf fonts won't work.}
    \write16{}
  \else
    \PackageWarning{luaminimalotf}{luaminimalotf only works in PDF mode, otf fonts won't work.}
  \fi
\fi

\luadirect{luaminimalotf.add_callback()}

%    \end{macrocode}
%
% \iffalse
%</package>
% \fi
%
% \Finale
\endinput
